<h1>String Interpolation</h1>

	<p>Example:</p>
	<strong>
		<p>name = "Ada"<br>
		puts "Hello, #{name}!"</p>
	</strong>

	<p>Using this syntax everything between the opening #{ and closing } bits is evaluated as Ruby code, and the result of this evaluation will be embedded into the string surrounding it.</p>

	<p>In other words, when Ruby finds #{name} in this string, then it will evaluate the piece of Ruby code name. It finds that this is a variable, so it returns the value of the variable, which is the string "Ada". So it embeds it into the surrounding string "Hello, #{name}!", by replacing #{name}.
	<br><br>
	String interpolation only works with double quotes.
	</p>

	<p>That means that:</p>

	<strong>
		<p>puts "Interpolation works in double quoted strings: #{1 + 2}."<br>
		puts 'And it does not work in single quoted strings: #{1 + 2}.'</p>
	</strong>

	<p>will print out:</p>
	<strong>
		<p>Interpolation works in double quoted strings: 3. <br>
		And it does not work in single quoted strings: #{1 + 2}.</p>
	</strong>
	<p>If you type the code above in your editor, and syntax highlighting for Ruby code is used, it should highlight the code in the double quoted string, so it gives you a visual clue about the interpolation.</p>

<h1>Array Declaration and adding an element at the end of the array</h1>

	<h2>Declaration</h2>

		<p>
		A new array can be created by using the literal constructor []. Arrays can contain different types of objects. For example, the array below contains an Integer, a String and a Float:</p>

		<strong>
			<p>ary = [1, "two", 3.0] #=> [1, "two", 3.0]</p>
		</strong>
		<p>
		An array can also be created by explicitly calling ::new with zero, one (the initial size of the Array) or two arguments (the initial size and a default object).
		</p>
		<strong>
		<p>
		ary = Array.new    #=> [] <br>
		Array.new(3)       #=> [nil, nil, nil] <br>
		Array.new(3, true) #=> [true, true, true] <br>
		</p>
		</strong>

		<p>you can also use</p>
		<strong>
			<p>array = %W(juice eggs bread) #=> [juice, eggs, bread] </p>
		</strong>
		<p>this creates an array with commas where there are spaces.</p>

	<h2>Adding an element at the end of the array</h2>
		<p>Items can be added to the end of an array by using either push or << </p>
		<strong>
			<p>
			arr = [1, 2, 3, 4] <br>
			arr.push(5) #=> [1, 2, 3, 4, 5] <br>
			arr << 6    #=> [1, 2, 3, 4, 5, 6] <br>
			</p>
		</strong>
<h1>Array iteration using each command</h1>

	<h3>each { |item| block } → ary <br>
	each → Enumerator </h3>

		<p>Calls the given block once for each element in self, passing that element as a parameter.</p>

		<p>An Enumerator is returned if no block is given.</p>
		<strong>
			<p>
			a = [ "a", "b", "c" ] <br>
			a.each {|x| print x, " -- " } <br>
			</p>
		</strong>
		<p>produces:</p>
		<strong>
			<p>
				a -- b -- c --
			</p>
		</strong>

	<h3>each_index { |index| block } → ary
	each_index → Enumerator</h3>

		<p>
			Same as #each, but passes the index of the element instead of the element itself.
		</p>
		<p>An Enumerator is returned if no block is given.</p>
		<strong>
			<p>
				a = [ "a", "b", "c" ] <br>
				a.each_index {|x| print x, " -- " }
			</p>
		</strong>

		<p>produces:</p>

		<strong>
			<p>0 -- 1 -- 2 --</p>
		</strong>
		<p>Example for adding the elements of an array</p>
		<strong>
			<p>
			nums = [1,2,3,4] <br><br>
			nums.each do |num| <br>
			sum = num + sum <br>
			end <br>
			</p>
			<p>sum #=> 10</p>
		</strong>
<h1>Hash Declaration</h1>
	<p>A Hash is a dictionary-like collection of unique keys and their values. Also called associative arrays, they are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type.
	</p>
	<p>Hashes enumerate their values in the order that the corresponding keys were inserted.</p>
	<p>A Hash can be easily created by using its implicit form:</p>
	<strong>
		<p>
			grades = { "Jane Doe" => 10, "Jim Doe" => 6 }
		</p>
	</strong>
	<p>Hashes allow an alternate syntax for keys that are symbols. Instead of</p>
	<strong>
		<p>
			options = { :font_size => 10, :font_family => "Arial" }
		</p>
	</strong>
	<p>You could write it as:</p>
	<strong>
		<p>
			options = { font_size: 10, font_family: "Arial" }
		</p>
	</strong>
	<p>A Hash can also be created through its ::new method:</p>
	<strong>
		<p>
			grades = Hash.new <br>
			grades["Dorothy Doe"] = 9
		</p>
	</strong>
<h1>Hash iteration using each command</h1>
	<h3>each { |key, value| block } → ary <br>
	each → Enumerator </h3>

		<p>Calls the given block once for each element in self, passing that element as a parameter.</p>

		<p>An Enumerator is returned if no block is given.</p>
		<strong>
			<p>
			a = { :a => "a", :b => "b", :c => "c" } <br>
			a.each {|x,y| print y, " -- " } <br>
			</p>
		</strong>
		<p>produces:</p>
		<strong>
			<p>
				a -- b -- c --
			</p>
		</strong>

<h1>Block, definition and example</h1>

		<p>In computer programming, a block or code block is a lexical structure of source code which is grouped together. Blocks consist of one or more declarations and statements. A programming language that permits the creation of blocks, including blocks nested within other blocks, is called a block-structured programming language. Blocks are fundamental to structured programming, where control structures are formed from blocks.</p>
		<p>The function of blocks in programming is to enable groups of statements to be treated as if they were one statement, and to narrow the lexical scope of variables, procedures and functions declared in a block so that they do not conflict with variables having the same name used elsewhere in a program for different purposes. In a block-structured programming language, the names of variables and other objects such as procedures which are declared in outer blocks are visible inside other inner blocks, unless they are shadowed by an object of the same name.</p>

		<p>An example of a block of code in rails console would be:</p>
		<strong>
			<p>
				>> %w[A B C].map { |char| char.downcase } <br>
				=> ["a", "b", "c"] <br>
			</p>
		</strong>
			<p>char.downcase, being the block of code inside the {}. The main purpose is the be able to use pieces of code in an organized way and being able to store them for future use, for example in case of storing a block of code inside a method.</p>
<h1>Ruby's convention for naming variables</h1>

		<strong><span>Variable</strong> - e.g. order_amount, total. </span><span>Variables are named where all letters are lowercase and words are separated by underscores.</span>
		<strong><p>Local Variables</p></strong>
		<p>These should be a lowercase letter followed by other characters, naming convention states that it is better to use underscores rather than camelBack for multiple word names, e.g. mileage, variable_xyz.</p>
		<strong><p>Instance Variables</p></strong>
		<p>Instance variables are defined using the single "at" sign (@) followed by a name. It is suggested that a lowercase letter should be used after the @, e.g. @colour</p>
		<strong><p>Class Variables</p></strong>
		<p>Class variable names start with a double "at" sign (@@) and may be followed by digits, underscores, and letters, e.g. @@colour</p>

<h1>View on attr_reader, attr_writer y attr_accesor</h1>

		<strong><h2>Reading the data in an object</h2></strong>

		<p>Suppose that we want to read the data in the address object. To do this, we need to write a method that returns this data:</p>

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize(street)</p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = street</p>     
				   <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>

				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp# Just return @street</p>
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef street</p> 
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street</p>    
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>
			<p>end</p>
		</strong>
		<p>Now the method Address#street lets you read the street of the address. In irb:</p>

		<strong><p>>> address.street</p></strong>
		<strong><p>=> "23 St George St."</p></strong>
		<span>A property of an object, which is visible outside, is called an attribute. In this case, street is is an attribute. In particular, it is a readable attribute. Because this kind of attribute is very common, Ruby offers you a shortcut through the</span> 
		<strong><span>attr_reader</span></strong> <span>keyword:</span>

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attr_reader :self </p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize(street)</p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = street</p>     
				   <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>

			<p>end</p>
		</strong>






		<strong><h2>Changing the data in an object</h2></strong>

		<p>We can also define a method to change the data in an object.</p>

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp attr_reader :street</p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize(street)</p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = street</p>     
				   <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>

				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef street = (street)</p> 
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = street</p>    
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>
			<p>end</p>
		</strong>
		<p>Ruby is pretty smart in its use of the street= method:</p>

		<strong><p>address.street = "45 Main St."</p></strong>

		<span>Notice that you can put spaces betten street and =. Now that we can change the address data, we can simplify the initialize method, and have it simply default the street to the empty string "".</span> 

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attr_reader :street </p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize </p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = ""</p>     
				   <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef street = (street)</p> 
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = street</p>    
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>
			<p>end</p>
		<p>address = Address.new</p>
		<p>address.street = "23 St George St."</p>
		</strong>

		<p>This might not seem like much of a simplification, but when we add the city, state and zip fields, and more methods this will make the class definition a bit simpler.</p>

		<span>Now, street is also a writable attribute. As before, you can declare it as such with</span> 
		<strong><span>attr_writer</span></strong> <span>:</span>

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attr_reader :street </p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attr_writer :street </p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize </p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = ""</p>     
				   <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>

			<p>end</p>
		</strong>

<strong><h2>Accessing data</h2></strong>

		<span>Very often, you have attributes that are both readable and writable attributes. Ruby lets you lump these together with</span> 
		<strong><span>attr_accessor</span></strong><span>. I guess these would be called "accessible attributes", but I have never seen them be called that.</span>

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp attr_accessor :street</p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize</p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = ""</p>        
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>
			<p>end</p>
		</strong>

		<span>With this knowledge, it is now easy to define the entire addressbook structure. As it turns out,</span> <strong><span>attr_accessor</span></strong><span> and friends all accept multiple arguments.</span>

		<strong>
			<p>class Address</p>
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp attr_accessor :street, :city, :state, :zip </p> 
				<p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspdef initialize </p>     
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp@street = @city = @state = @zip = ""</p>        
				    <p>&nbsp&nbsp&nbsp&nbsp&nbsp&nbspend</p>
			<p>end</p>

<br>
<%= link_to "Home", root_path %>



